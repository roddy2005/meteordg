<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="theme-color" content="#0b1020" />
  <title>Meteor Dodge</title>
  <style>
    :root{
      --bg0:#070b1a; --bg1:#0b1020; --bg2:#0e1430; --glass:rgba(255,255,255,.08);
      --card:rgba(10,16,40,.72); --border:rgba(255,255,255,.12); --muted:rgba(230,236,255,.82);
      --accent:#79c0ff; --accent2:#7bf0ff; --warn:#ffd166;
    }
    html, body { margin:0; height:100%;
      background: radial-gradient(1200px 800px at 20% 10%, var(--bg2), transparent),
                  radial-gradient(900px 700px at 80% 30%, #121a3a66, transparent),
                  linear-gradient(180deg, var(--bg1), var(--bg0));
      color:#e6ecff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Apple SD Gothic Neo, "Malgun Gothic", sans-serif;
      overscroll-behavior:none; -webkit-touch-callout:none; -webkit-tap-highlight-color:transparent;
    }
    #ui { position: fixed; inset: 0; pointer-events: none; }
    .hud { position: absolute; left: 12px; top: 12px; display:none; gap:10px; align-items:center; pointer-events: auto; }
    .score-pill{ position:absolute; left:50%; top:14px; transform:translateX(-50%); pointer-events:none; }
    .pill{ background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      border:1px solid var(--border); border-radius: 999px; padding:8px 14px; box-shadow: 0 8px 24px rgba(0,0,0,.35);
    }
    .card { background: var(--card); backdrop-filter: blur(10px); border:1px solid var(--border); border-radius: 16px; padding:12px 16px; box-shadow: 0 6px 24px rgba(0,0,0,.4); }
    .btn { pointer-events:auto; appearance: none; border: 1px solid var(--border); background: rgba(255,255,255,.06); color:#e6ecff; padding:12px 16px; border-radius:14px; font-weight:700; cursor:pointer; transition: transform .08s ease, background .2s ease, box-shadow .2s ease; }
    .btn:hover { background: rgba(255,255,255,.12); box-shadow: 0 6px 16px rgba(0,0,0,.25); }
    .btn:active{ transform: translateY(1px) scale(.99); }
    .btn.primary{ background: linear-gradient(180deg, #2a7cff, #2569f8); border-color: transparent; color:white; box-shadow: 0 10px 24px rgba(37,105,248,.35); }
    .btn.primary:hover{ filter: brightness(1.05); }
    .btn.icon{ width:40px; height:40px; display:grid; place-items:center; padding:0; border-radius:12px; font-size:18px; }
    #soundCtl{ position:absolute; right:12px; top:12px; pointer-events:auto; }

    #centerOverlay { position: absolute; inset: 0; display:flex; align-items:center; justify-content:center; pointer-events:auto; }
    .panel { width:min(92vw, 520px); background: rgba(10,16,40,.85); border:1px solid var(--border); border-radius: 22px; padding: 24px; box-shadow: 0 16px 48px rgba(0,0,0,.55); }
    .title { font-size: clamp(26px, 5vw, 40px); font-weight: 900; margin: 0 0 8px; letter-spacing: .4px; background: linear-gradient(90deg, var(--accent), var(--accent2)); -webkit-background-clip:text; background-clip:text; color: transparent; }
    .muted { color: var(--muted); font-size:14px; }
    .row { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; }
    .grow { flex:1 1 auto; }
    input[type="text"] { width: 100%; background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.18); color:#e6ecff; padding:12px 14px; border-radius: 12px; outline: none; font-size: 16px; }
    #leaderboard { max-height: 240px; overflow:auto; }
    ol#lbList{ list-style:none; margin:0; padding:0; counter-reset: rank; display:flex; flex-direction:column; gap:8px; }
    ol#lbList li{ counter-increment: rank; display:flex; align-items:center; justify-content:space-between; gap:10px; background: rgba(255,255,255,.04); border:1px solid var(--border); border-radius:12px; padding:10px 12px; }
    ol#lbList li::before{ content: counter(rank) "."; opacity:.6; width:2ch; margin-right:6px; }
    #footer { position: absolute; right: 12px; bottom: 12px; opacity:.7; font-size: 12px; padding-bottom: env(safe-area-inset-bottom); }
    canvas { display:block; touch-action: none; }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="ui">
    <div class="hud"></div>
    <div class="score-pill pill">점수 <b id="score">0</b></div>
    <div id="soundCtl"><button id="soundBtn" class="btn icon" type="button" aria-label="사운드">🔊</button></div>
    <div id="centerOverlay">
      <div class="panel">
        <h1 class="title" id="overlayTitle">Meteor Dodge</h1>
        <p class="muted" id="overlayDesc">손가락을 대고 비행선을 움직여 운석을 피하세요. 시간이 지날수록 더 어려워집니다.</p>

        <div id="gameOverBlock" hidden>
          <p style="margin:.5rem 0 0">이번 점수: <b id="finalScore">0</b></p>
          <div class="row" style="margin-top:10px">
            <input id="nickname" type="text" maxlength="16" placeholder="닉네임" class="grow" />
            <button id="saveBtn" class="btn" type="button">랭킹 등록</button>
          </div>
          <p class="muted" id="saveStatus" style="min-height:1.2em"></p>
        </div>

        <div style="display:flex; gap:12px; margin-top:12px; flex-wrap:wrap">
          <button id="startBtn" class="btn primary" style="font-size:18px" type="button">▶ 시작</button>
          <button id="restartBtn" class="btn" hidden type="button">다시 시작</button>
        </div>

        <h3 style="margin:16px 0 6px">🏆 실시간 랭킹 Top 10</h3>
        <div id="leaderboard" class="card" style="padding:12px">
          <ol id="lbList"></ol>
        </div>
      </div>
    </div>
    <div id="footer">Made for mobile · 드래그/터치 조작</div>
  </div>

  <!-- 배경음악 (같은 폴더에 bgm.mp3 넣어주세요) -->
  <audio id="bgm" src="bgm.mp3" preload="auto" loop></audio>

  <script type="module">
    import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

    // 1) 여기에 본인 프로젝트 값 채우기 (환경변수 권장)
    const SUPABASE_URL = "https://hgjdlqqhvgwzszwwnlpr.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhnamRscXFodmd3enN6d3dubHByIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUxMzU4MDEsImV4cCI6MjA3MDcxMTgwMX0.yveInn8yTSH3325zIJ6wKjH72JyrKZBvaTngEuKDNJY";

    // 2) Supabase 클라이언트 (플레이스홀더면 비활성화)
    const hasCreds =
      SUPABASE_URL.startsWith('http') &&
      !SUPABASE_URL.includes('REPLACE') &&
      SUPABASE_ANON_KEY &&
      !SUPABASE_ANON_KEY.includes('REPLACE');

    const sb = hasCreds ? createClient(SUPABASE_URL, SUPABASE_ANON_KEY) : null;

    // DOM
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const overlay = document.getElementById('centerOverlay');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayDesc = document.getElementById('overlayDesc');
    const gameOverBlock = document.getElementById('gameOverBlock');
    const finalScoreEl = document.getElementById('finalScore');
    const nicknameInput = document.getElementById('nickname');
    const saveBtn = document.getElementById('saveBtn');
    const saveStatus = document.getElementById('saveStatus');
    const lbList = document.getElementById('lbList');
    const soundBtn = document.getElementById('soundBtn');
    const bgmEl = document.getElementById('bgm');

    // 캔버스 크기 & DPR (iOS 주소창/노치 대응: visualViewport 활용)
    const state = {
      w: 0, h: 0, dpr: 1,
      running: false,
      time: 0, score: 0, lastSpawn: 0, spawnInterval: 1200,
      meteors: [],
      meteorParticles: [],
      particleCap: 3000,
      shipTrail: [],
      pointer: { active:false, x:0, y:0 },
      ship: { x:0, y:0, r: 18, speed: 0.18, angle: -Math.PI/2 },
      overlayFX: { active:false, t:0, dir: -1 }, // dir:-1 = fade out (start), 1 = fade in (game over)
      warmupMs: 2500, // 시작 2.5초는 스폰 금지 (튜토리얼/적응 시간)
      starLayers: [],
      nebulae: []
    };

    // 성능/품질 스케일러 + 스프라이트 캐시
    const PERF = { targetFPS: 55, fpsEMA: 60, low: false, lastCheck: 0 };
    const SPRITES = { starS:null, starM:null, starL:null, particle:null };

    // ====== 유틸 선언 (fit 이전에도 사용 가능) ======
    function rand(a,b){ return a + Math.random()*(b-a); }
    const clamp01 = (x)=> Math.max(0, Math.min(1, x));
    const smoothstep = (e0,e1,x)=>{ const t = clamp01((x-e0)/(e1-e0)); return t*t*(3-2*t); };
    const easeInOut = (t)=> t<0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2;
    function tailParams(m){
      const speed = Math.hypot(m.vx, m.vy);
      const tail = Math.max(m.r*0.8, Math.min(140, speed*0.6));
      const width = Math.max(m.r*0.6, Math.min(60, speed*0.3));
      return { tail, width, speed };
    }

    // 스프라이트 생성기 (라디얼 그라데이션을 1회만 생성)
    function makeRadialSprite(r, inner, outer){
      const c = document.createElement('canvas');
      const d = Math.ceil(r*2); c.width = c.height = d;
      const g = c.getContext('2d');
      const grd = g.createRadialGradient(r, r, 0, r, r, r);
      grd.addColorStop(0, inner); grd.addColorStop(1, outer);
      g.fillStyle = grd; g.beginPath(); g.arc(r, r, r, 0, Math.PI*2); g.fill();
      return c;
    }
    function ensureSprites(){
      if(!SPRITES.starS){ SPRITES.starS = makeRadialSprite(1.6, 'rgba(255,255,255,1)', 'rgba(255,255,255,0)'); }
      if(!SPRITES.starM){ SPRITES.starM = makeRadialSprite(2.2, 'rgba(255,255,255,1)', 'rgba(255,255,255,0)'); }
      if(!SPRITES.starL){ SPRITES.starL = makeRadialSprite(3.0, 'rgba(255,255,255,1)', 'rgba(255,255,255,0)'); }
      if(!SPRITES.particle){ SPRITES.particle = makeRadialSprite(6, 'rgba(255,200,150,0.9)', 'rgba(255,200,150,0)'); }
    }

    // ====== 오디오 컨트롤 ======
    const audioCtl = { ctx: null, gain: null, enabled: true, tried:false, vol: 0.35 };
    function initAudio(){
      if(audioCtl.ctx) return;
      const AC = window.AudioContext || window.webkitAudioContext;
      if(!AC) return; // 구형 브라우저
      audioCtl.ctx = new AC();
      audioCtl.gain = audioCtl.ctx.createGain();
      const src = audioCtl.ctx.createMediaElementSource(bgmEl);
      src.connect(audioCtl.gain).connect(audioCtl.ctx.destination);
      audioCtl.gain.gain.value = audioCtl.vol;
    }
    function resumeCtx(){ if(audioCtl.ctx && audioCtl.ctx.state === 'suspended') audioCtl.ctx.resume().catch(()=>{}); }
    function playBgm(){
      audioCtl.tried = true; initAudio(); resumeCtx();
      bgmEl.volume = 1; // 볼륨은 Gain Node로 제어
      return bgmEl.play().catch(()=>{});
    }
    function pauseBgm(){ bgmEl.pause(); }
    function fadeTo(volume, ms=300){
      if(!audioCtl.gain || !audioCtl.ctx) return;
      const g = audioCtl.gain.gain; const now = audioCtl.ctx.currentTime;
      g.setValueAtTime(g.value, now); g.linearRampToValueAtTime(Math.max(0,Math.min(1,volume)), now + ms/1000);
    }
    function setSound(on){
      audioCtl.enabled = on; localStorage.setItem('md.sound', on?'on':'off');
      soundBtn.textContent = on ? '🔊' : '🔇';
      if(on){ if(state.running) { playBgm().then(()=>fadeTo(audioCtl.vol, 250)); } }
      else { pauseBgm(); }
    }

    // 초기 사운드 상태
    setSound(localStorage.getItem('md.sound') !== 'off');
    soundBtn.addEventListener('click', ()=> setSound(!audioCtl.enabled));

    // 첫 유저 제스처에서 오디오 컨텍스트 깨우기
    window.addEventListener('pointerdown', ()=>{ if(!audioCtl.tried && audioCtl.enabled){ playBgm().then(()=>fadeTo(audioCtl.vol, 200)); } }, {once:false});
    document.addEventListener('visibilitychange', ()=>{
      if(document.hidden){ pauseBgm(); }
      else if(audioCtl.enabled && state.running){ playBgm().then(()=>fadeTo(audioCtl.vol, 150)); }
    });

    function fit() {
      const dpr = Math.min(window.devicePixelRatio || 1, PERF.low ? 1.2 : 1.6);
      const vw = window.visualViewport ? Math.floor(window.visualViewport.width) : window.innerWidth;
      const vh = window.visualViewport ? Math.floor(window.visualViewport.height) : window.innerHeight;
      state.w = vw; state.h = vh; state.dpr = dpr;
      canvas.width = Math.floor(state.w * dpr);
      canvas.height = Math.floor(state.h * dpr);
      canvas.style.width = state.w + 'px';
      canvas.style.height = state.h + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ensureSprites();
      regenStars();
      regenNebulae();
    }
    window.addEventListener('resize', fit);
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', fit);
      window.visualViewport.addEventListener('scroll', fit);
    }
    fit();

    // 입력 (터치 스크롤/풀투리프레시 방지)
    function setPointer(e){
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX ?? (e.touches?.[0]?.clientX || 0)) - rect.left;
      const y = (e.clientY ?? (e.touches?.[0]?.clientY || 0)) - rect.top;
      state.pointer.x = Math.max(0, Math.min(state.w, x));
      state.pointer.y = Math.max(0, Math.min(state.h, y));
    }
    canvas.addEventListener('pointerdown', e=>{ state.pointer.active=true; setPointer(e); });
    canvas.addEventListener('pointermove', e=>{ if(state.pointer.active) setPointer(e); });
    window.addEventListener('pointerup', ()=>{ state.pointer.active=false; });

    canvas.addEventListener('touchstart', e=> e.preventDefault(), {passive:false});
    canvas.addEventListener('touchmove', e=> e.preventDefault(), {passive:false});
    document.addEventListener('touchmove', (e)=>{
      if(e.target === document.body || e.target === canvas) e.preventDefault();
    }, {passive:false});

    // ───────────────────────
    // Starfield & Nebula generators
    // ───────────────────────
    function regenStars(){
      const area = state.w * state.h;
      const total = Math.max(120, Math.min(240, Math.floor(area / 6000)));
      const c0 = Math.floor(total*0.3), c1 = Math.floor(total*0.45);
      const counts = [c0, c1, total - c0 - c1];
      const speeds = [4, 9, 18]; // px/s (소폭 감소로 저사양 최적화)
      const sizes = [[0.6,1.1],[0.8,1.6],[1.0,2.2]];
      const tw = [0.003,0.004,0.006];
      const palette = ['rgba(220,235,255,1)','rgba(255,236,200,1)','rgba(200,215,255,1)'];
      state.starLayers = [];
      for(let li=0; li<3; li++){
        const stars=[];
        for(let i=0;i<counts[li];i++){
          const r = rand(sizes[li][0], sizes[li][1]);
          const color = palette[(Math.random()*palette.length)|0];
          stars.push({x: Math.random()*state.w, y: Math.random()*state.h, r, baseA: rand(0.55, 1.0), twinkle: tw[li], phase: Math.random()*Math.PI*2, core: color});
        }
        const dir = Math.random()<0.5?1:-1;
        state.starLayers.push({stars, vx: speeds[li]*dir, vy: speeds[li]*0.15});
      }
    } // px/s
      const sizes = [[0.6,1.1],[0.8,1.6],[1.0,2.2]];
      const tw = [0.003,0.004,0.006];
      const palette = ['rgba(220,235,255,1)','rgba(255,236,200,1)','rgba(200,215,255,1)'];
      state.starLayers = [];
      for(let li=0; li<3; li++){
        const stars=[];
        for(let i=0;i<counts[li];i++){
          const r = rand(sizes[li][0], sizes[li][1]);
          const color = palette[(Math.random()*palette.length)|0];
          stars.push({x: Math.random()*state.w, y: Math.random()*state.h, r, baseA: rand(0.55, 1.0), twinkle: tw[li], phase: Math.random()*Math.PI*2, core: color});
        }
        const dir = Math.random()<0.5?1:-1;
        state.starLayers.push({stars, vx: speeds[li]*dir, vy: speeds[li]*0.15});
      }
    }
    function regenNebulae(){
      const n = 3;
      const colors = ['rgba(90,140,255,0.12)','rgba(180,100,255,0.10)','rgba(80,220,200,0.10)'];
      const minR = Math.min(state.w, state.h)*0.35, maxR = Math.min(state.w, state.h)*0.6;
      state.nebulae = [];
      for(let i=0;i<n;i++){
        const r = rand(minR, maxR);
        state.nebulae.push({
          x: rand(0, state.w), y: rand(0, state.h), r, a: rand(0.25,0.45),
          color1: colors[i%colors.length], vx: rand(-5,5), vy: rand(-3,3)
        });
      }
    }

    function spawnMeteor() {
      const edge = (Math.random()*4)|0;
      const size = rand(10, 28);
      let x,y;
      if(edge===0){ x = rand(0, state.w); y = -size-2; }
      else if(edge===1){ x = state.w+size+2; y = rand(0, state.h); }
      else if(edge===2){ x = rand(0, state.w); y = state.h+size+2; }
      else { x = -size-2; y = rand(0, state.h); }
      const targetX = state.ship.x + rand(-80,80);
      const targetY = state.ship.y + rand(-80,80);
      const dx = targetX - x; const dy = targetY - y; const len = Math.hypot(dx,dy) || 1;
      const baseSpeed = 70 + (state.time * 0.015);
      const vx = dx/len * baseSpeed; const vy = dy/len * baseSpeed;
      state.meteors.push({ x,y, r:size, vx, vy });
    }

    function resetGame() {
      state.time = 0; state.score = 0; state.lastSpawn = 0; state.spawnInterval = 1200;
      state.meteors.length = 0;
      state.ship.x = state.w*0.5; state.ship.y = state.h*0.7; state.ship.angle = -Math.PI/2;
      state.pointer.x = state.ship.x; state.pointer.y = state.ship.y;
    }

    function startGame() {
      // overlay fade-out + scale-down
      state.overlayFX.active = true; state.overlayFX.t = 0; state.overlayFX.dir = -1;
      overlay.hidden = true; overlay.style.display = 'none';
      gameOverBlock.hidden = true;
      state.running = true;
      resetGame();
      if (audioCtl.enabled){ playBgm().then(()=>fadeTo(audioCtl.vol, 250)); }
      if (screen.orientation && screen.orientation.lock) {
        screen.orientation.lock('portrait').catch(()=>{});
      }
    }

    function gameOver() {
      state.running = false;
      // overlay fade-in + scale-up
      state.overlayFX.active = true; state.overlayFX.t = 0; state.overlayFX.dir = 1;
      overlay.hidden = false; overlay.style.display = 'flex';
      overlayTitle.textContent = '게임 종료';
      overlayDesc.textContent = '운석과 충돌했습니다. 닉네임을 입력하고 랭킹에 등록해보세요!';
      gameOverBlock.hidden = false;
      finalScoreEl.textContent = state.score.toString();
      restartBtn.hidden = false; startBtn.hidden = true;
      nicknameInput.value = localStorage.getItem('md.nickname') || '';
      saveBtn.disabled = false; saveStatus.textContent = '';
      nicknameInput.focus();
      fadeTo(0.2, 200); // 게임오버 시 살짝 줄임
      fetchLeaderboard();
    }

    startBtn.addEventListener('click', startGame);
    startBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); startGame(); }, {passive:false});
    restartBtn.addEventListener('click', ()=>{ startBtn.hidden = true; startGame(); });
    restartBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); startGame(); }, {passive:false});

    // 리더보드
    async function fetchLeaderboard(){
      lbList.innerHTML = '<li class="muted">불러오는 중...</li>';
      if(!sb){ lbList.innerHTML = '<li class="muted">저장소가 설정되지 않아 랭킹을 불러올 수 없습니다.</li>'; return; }
      const { data, error } = await sb.from('scores')
        .select('nickname, score, created_at')
        .order('score', { ascending:false })
        .limit(10);
      if(error){ lbList.innerHTML = `<li class=\"muted\">오류: ${error.message}</li>`; return; }
      lbList.innerHTML = '';
      (data||[]).forEach((row)=>{
        const li = document.createElement('li');
        li.textContent = `${row.nickname} — ${row.score}`;
        lbList.appendChild(li);
      });
      if((data||[]).length===0){
        lbList.innerHTML = '<li class="muted">아직 점수가 없습니다. 첫 기록의 주인공이 되어보세요!</li>';
      }
    }

    async function saveScore(){
      const nick = (nicknameInput.value||'').trim().slice(0,16);
      if(!nick){ saveStatus.textContent = '닉네임을 입력하세요.'; return; }
      if(!sb){ saveStatus.textContent = '저장소가 설정되지 않아 저장할 수 없습니다.'; return; }
      const payload = { nickname: nick, score: state.score };
      saveBtn.disabled = true; saveStatus.textContent = '저장 중...';
      const { error } = await sb.from('scores').insert(payload);
      if(error){ saveStatus.textContent = '실패: '+error.message; saveBtn.disabled=false; return; }
      localStorage.setItem('md.nickname', nick);
      saveStatus.textContent = '저장 완료!';
      fetchLeaderboard();
    }
    saveBtn.addEventListener('click', saveScore);

    // 초기 오버레이 & 랭킹 로드
    overlay.hidden = false; fetchLeaderboard();

    // 렌더링
    function drawShip(){
      const { x, y, r } = state.ship;
      // 잔광(트레일)
      state.shipTrail.push({x, y, a: 0.35});
      if (state.shipTrail.length > 24) state.shipTrail.shift();
      for(let i=0;i<state.shipTrail.length;i++){
        const t = state.shipTrail[i];
        const alpha = Math.max(0, t.a - i*0.02);
        if(alpha<=0) continue;
        const grd = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, r*1.2);
        grd.addColorStop(0, `rgba(123,240,255,${alpha*0.35})`);
        grd.addColorStop(1, 'rgba(123,240,255,0)');
        ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(t.x, t.y, r*1.5, 0, Math.PI*2); ctx.fill();
      }
      // 본체(네온 우주선)
      ctx.save(); ctx.translate(x,y); ctx.rotate(state.ship.angle + Math.PI/2);
      const g = ctx.createLinearGradient(0,-r*1.6,0,r*1.8);
      g.addColorStop(0,'#9ad7ff'); g.addColorStop(1,'#5fb3ff');
      ctx.beginPath();
      ctx.moveTo(0, -r*1.3);
      ctx.quadraticCurveTo(r*0.9, -r*0.2, r*0.8, r*1.0);
      ctx.lineTo(-r*0.8, r*1.0);
      ctx.quadraticCurveTo(-r*0.9, -r*0.2, 0, -r*1.3);
      ctx.closePath();
      ctx.fillStyle = g; ctx.shadowColor = '#6bd1ff'; ctx.shadowBlur = 18; ctx.fill();
      ctx.shadowBlur = 0;
      // 캐노피
      ctx.beginPath(); ctx.ellipse(0, -r*0.2, r*0.45, r*0.3, 0, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,.6)'; ctx.fill();
      // 테두리
      ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(255,255,255,.35)'; ctx.stroke();
      // 엔진 화염
      ctx.beginPath();
      ctx.moveTo(0, r*1.0); ctx.lineTo(r*0.38, r*1.8); ctx.lineTo(-r*0.38, r*1.8); ctx.closePath();
      const flame = ctx.createLinearGradient(0, r*1.0, 0, r*1.8);
      flame.addColorStop(0,'#ffe08a'); flame.addColorStop(1,'#ff6b6b');
      ctx.fillStyle = flame; ctx.fill();
      ctx.restore();
    }

    function drawMeteor(m){
      // (변경) 빛 플레어 제거 → 불꽃 파티클만 남김
      const tp = tailParams(m);
      const fAng = Math.atan2(m.vy, m.vx); // 정방향(이동 방향)

      // 꼬리 파티클(불똥) — 이동 반대 방향(-정방향)에서 방출
      const backX = m.x - Math.cos(fAng) * (m.r*0.6);
      const backY = m.y - Math.sin(fAng) * (m.r*0.6);
      const count = Math.min(16, Math.max(10, Math.round(tp.speed / 26)));
      for(let k=0; k<count && state.meteorParticles.length < state.particleCap; k++){
        state.meteorParticles.push({
          x: backX + rand(-2.6,2.6),
          y: backY + rand(-2.6,2.6),
          vx: -m.vx*0.12 + rand(-16,16),
          vy: -m.vy*0.12 + rand(-16,16),
          r: Math.max(2.0, m.r*0.24*rand(0.7,1.3)),
          a: 0.35
        });
      }

      // 본체(광택 있는 운석)
      const g = ctx.createRadialGradient(m.x-m.r*0.3, m.y-m.r*0.3, m.r*0.1, m.x, m.y, m.r);
      g.addColorStop(0, '#f5a67a');
      g.addColorStop(1, '#8a4025');
      ctx.fillStyle = g; ctx.beginPath(); ctx.arc(m.x, m.y, m.r, 0, Math.PI*2); ctx.fill();
      // 림 하이라이트
      ctx.strokeStyle = 'rgba(255,230,210,.25)'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(m.x, m.y, m.r*0.92, Math.PI*0.1, Math.PI*0.6); ctx.stroke();
      // 작은 크레이터
      ctx.fillStyle = 'rgba(0,0,0,.15)';
      for(let i=0;i<3;i++){ ctx.beginPath(); ctx.arc(m.x+rand(-m.r*0.4,m.r*0.4), m.y+rand(-m.r*0.4,m.r*0.4), m.r*rand(0.08,0.16), 0, Math.PI*2); ctx.fill(); }
    }

    function update(dt){
      state.time += dt;
      const targetInterval = Math.max(260, 1200 - state.time * 0.15);
      state.spawnInterval += (targetInterval - state.spawnInterval)*0.05;
      // 스폰: 워밍업 이후 서서히 강해지도록 확률적 게이팅 + 부드러운 배치 증가
      if(state.time >= state.warmupMs && (state.time - state.lastSpawn > state.spawnInterval)){
        const afterWarm = state.time - state.warmupMs;
        const warmRamp = smoothstep(0, 4000, afterWarm); // 워밍업 종료 후 4초 동안 0→1로 천천히
        if(Math.random() < warmRamp){
          state.lastSpawn = state.time;
          // 멀티 스폰 확률을 5s→35s 사이에서 부드럽게 0→0.6로
          const chaos = 0.6 * easeInOut(clamp01((state.time - 5000) / 30000));
          let batch = 1;
          if(Math.random() < chaos) batch++;
          if(Math.random() < chaos * 0.35) batch++; // 늦게 갈수록 드물게 3개
          const cap = 6 + Math.floor(state.time / 10000); // (테스트 유지) 동시 수 상한은 정수 그대로
          for(let i=0;i<batch && state.meteors.length < cap;i++) spawnMeteor();
        }
      }
      state.score = Math.floor(state.time/100);
      state.ship.x += (state.pointer.x - state.ship.x) * state.ship.speed;
      state.ship.y += (state.pointer.y - state.ship.y) * state.ship.speed;
      // 회전: 포인터 방향을 향하도록 각도 보간
      {
        const dxp = state.pointer.x - state.ship.x;
        const dyp = state.pointer.y - state.ship.y;
        const targetAng = Math.atan2(dyp, dxp);
        const a = state.ship.angle;
        let diff = ((targetAng - a + Math.PI) % (Math.PI*2)) - Math.PI; // [-π, π]
        const lerp = Math.min(1, 0.12 + 0.0003 * state.time); // 점점 더 민첩하게 회전
        state.ship.angle = a + diff * lerp;
      }
      // 운석 이동
      for(const m of state.meteors){ m.x += m.vx * dt/1000; m.y += m.vy * dt/1000; }
      // 별자리/성운 드리프트 & 래핑
      for(const L of state.starLayers){
        for(const s of L.stars){
          s.x += L.vx * dt/1000; s.y += L.vy * dt/1000;
          if(s.x < -s.r) s.x += state.w + s.r; if(s.x > state.w + s.r) s.x -= state.w + s.r;
          if(s.y < -s.r) s.y += state.h + s.r; if(s.y > state.h + s.r) s.y -= state.h + s.r;
        }
      }
      for(const nb of state.nebulae){
        nb.x += nb.vx*dt/1000; nb.y += nb.vy*dt/1000;
        const pad = nb.r*0.5;
        if(nb.x < -pad) nb.x += state.w + pad*2; if(nb.x > state.w + pad) nb.x -= state.w + pad*2;
        if(nb.y < -pad) nb.y += state.h + pad*2; if(nb.y > state.h + pad) nb.y -= state.h + pad*2;
      }
      // 파티클 업데이트
      for(const p of state.meteorParticles){
        if (p.a < 0.06) continue;
        ctx.globalAlpha = Math.max(0, p.a) * 0.8;
        const img = SPRITES.particle;
        const s = p.r*2; ctx.drawImage(img, p.x - p.r, p.y - p.r, s, s);
      }
      ctx.globalAlpha = 1;
      ctx.restore();
      // 운석
      for(const m of state.meteors) drawMeteor(m);
      // 비행선
      drawShip();
      // HUD
      scoreEl.textContent = state.score.toString();
    }

    let lastTs = performance.now();
    function loop(ts){
      if(!state.running){ requestAnimationFrame(loop); return; }
      const dt = Math.min(32, ts - lastTs); lastTs = ts;
      update(dt); render();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    overlayTitle.textContent = 'Meteor Dodge';
    overlayDesc.textContent = '터치를 누르고 드래그하면 비행선이 따라옵니다. 운석을 피해 오래 살아남으세요!';

    // ───────────────────────
    // Runtime tests (opt-in)
    // ───────────────────────
    function assert(name, cond){ if(!cond) throw new Error('Test failed: '+name); console.log('✓', name); }
    async function runTests(){
      console.log('[TEST] start');
      // Sound: element exists & preference toggles
      assert('sound button exists', !!document.getElementById('soundBtn'));
      assert('bgm element exists', !!document.getElementById('bgm'));

      // startGame hides overlay and sets running + tries to play BGM
      startGame();
      assert('running true', state.running === true);
      assert('overlay hidden', overlay.hidden === true && overlay.style.display === 'none');
      assert('bgm tried to play', audioCtl.tried === true || audioCtl.enabled === false);

      // meteor spawn creates valid object
      const before = state.meteors.length;
      spawnMeteor();
      assert('meteor spawned', state.meteors.length === before + 1);
      const m = state.meteors[state.meteors.length-1];
      assert('meteor velocity finite', Number.isFinite(m.vx) && Number.isFinite(m.vy));

      // collision triggers gameOver
      m.x = state.ship.x; m.y = state.ship.y; m.r = 50; update(0);
      assert('collision triggers gameOver', state.running === false);

      // trail renders
      startGame(); state.pointer.x = state.ship.x + 100; update(16); render();
      assert('ship trail created', state.shipTrail.length > 0);

      // rotation checks
      startGame(); state.pointer.x = state.ship.x + 200; state.pointer.y = state.ship.y; for(let t=0;t<15;t++){ update(16); }
      let angDiff = Math.abs(((state.ship.angle - 0 + Math.PI) % (Math.PI*2)) - Math.PI);
      assert('ship rotates right', angDiff < 0.5);
      startGame(); state.pointer.x = state.ship.x; state.pointer.y = state.ship.y - 200; for(let t=0;t<15;t++){ update(16); }
      angDiff = Math.abs(((state.ship.angle - (-Math.PI/2) + Math.PI) % (Math.PI*2)) - Math.PI);
      assert('ship rotates up', angDiff < 0.5);

      // warmup prevents early spawns
      startGame(); const beforeWarm = state.meteors.length; update(1000);
      assert('no spawn during warmup', state.meteors.length === beforeWarm);

      // cap respected after time
      startGame(); for(let t=0;t<6000;t+=300){ update(300); }
      const cap = 6 + Math.floor(state.time / 10000);
      assert('cap respected', state.meteors.length <= cap);

      // tail params bounds
      let tp = tailParams({vx:0, vy:0, r:20});
      assert('tail >= r*0.8 when slow', tp.tail >= 16);
      assert('width >= r*0.6 when slow', tp.width >= 12);
      tp = tailParams({vx:1000, vy:0, r:20});
      assert('tail <= 140 cap', tp.tail <= 140);

      // opposite velocity checks
      { const testM = {x:100, y:100, r:20, vx:60, vy:0}; const ang = Math.atan2(testM.vy, testM.vx) + Math.PI; const backX = testM.x + Math.cos(ang) * (testM.r*0.6); const backY = testM.y + Math.sin(ang) * (testM.r*0.6); const v=[testM.vx,testM.vy]; const b=[backX-testM.x, backY-testM.y]; const dot=v[0]*b[0]+v[1]*b[1]; assert('tail back point opposite velocity', dot < 0); }
      { const testM2 = {x:0, y:0, r:20, vx:0, vy:80}; const fAng = Math.atan2(testM2.vy, testM2.vx); const tailDir=[-Math.cos(fAng), -Math.sin(fAng)]; const vel=[testM2.vx,testM2.vy]; const dot2=tailDir[0]*vel[0]+tailDir[1]*vel[1]; assert('tail flare opposite velocity', dot2 < 0); }

      // drawMeteor safety
      try { drawMeteor({x:120, y:90, r:14, vx:80, vy:0}); assert('drawMeteor did not throw', true); } catch(e) { throw new Error('drawMeteor threw: '+e.message); }

      // particle cap respected
      startGame(); for(let i=0;i<30;i++){ spawnMeteor(); } for(let t=0;t<4000;t+=16){ update(16); }
      assert('particle cap respected', state.meteorParticles.length <= state.particleCap);

      // starfield populated
      assert('star layers exist', Array.isArray(state.starLayers) && state.starLayers.length===3);
      const totalStars = state.starLayers.reduce((acc,L)=> acc + L.stars.length, 0);
      assert('stars populated', totalStars >= 100);
      assert('nebulae populated', Array.isArray(state.nebulae) && state.nebulae.length >= 2);

      // pause removed
      assert('no pause button', !document.getElementById('pauseBtn'));
      const t0 = state.time; update(16); assert('update not gated by pause', state.time > t0);

      console.log('[TEST] all passed');
      alert('All runtime tests passed.');
    }
    if (location.search.includes('test=1')) { runTests().catch(e=>{ console.error(e); alert(e.message); }); }

  </script>

  <!-- (선택) PWA 설치를 원하면 HTTPS 배포 후 아래 두 파일을 함께 올리세요. -->
  <!-- manifest.json
  {
    "name": "Meteor Dodge",
    "short_name": "Meteor",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0b1020",
    "theme_color": "#0b1020",
    "icons": [
      { "src": "icon-192.png", "sizes": "192x192", "type": "image/png" },
      { "src": "icon-512.png", "sizes": "512x512", "type": "image/png" }
    ]
  }
  -->
  <!-- sw.js
  const CACHE = 'md-v1';
  self.addEventListener('install', e=>{
    e.waitUntil(caches.open(CACHE).then(c=>c.addAll(['./','./index.html'])));
  });
  self.addEventListener('fetch', e=>{
    e.respondWith(caches.match(e.request).then(r=> r || fetch(e.request)));
  });
  -->
</body>
</html>
