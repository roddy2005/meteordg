<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="theme-color" content="#0b1020" />
  <title>Meteor Dodge</title>
  <style>
    :root{
      --bg0:#070b1a; --bg1:#0b1020; --bg2:#0e1430; --glass:rgba(255,255,255,.08);
      --card:rgba(10,16,40,.72); --border:rgba(255,255,255,.12); --muted:rgba(230,236,255,.82);
      --accent:#79c0ff; --accent2:#7bf0ff; --warn:#ffd166;
    }
    html, body { margin:0; height:100%;
      background: radial-gradient(1200px 800px at 20% 10%, var(--bg2), transparent),
                  radial-gradient(900px 700px at 80% 30%, #121a3a66, transparent),
                  linear-gradient(180deg, var(--bg1), var(--bg0));
      color:#e6ecff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Apple SD Gothic Neo, "Malgun Gothic", sans-serif;
      overscroll-behavior:none; -webkit-touch-callout:none; -webkit-tap-highlight-color:transparent;
    }
    #ui { position: fixed; inset: 0; pointer-events: none; }
    .hud { position: absolute; left: 12px; top: 12px; display:flex; gap:10px; align-items:center; pointer-events: auto; }
    .score-pill{ position:absolute; left:50%; top:14px; transform:translateX(-50%); pointer-events:none; }
    .pill{ background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      border:1px solid var(--border); border-radius: 999px; padding:8px 14px; box-shadow: 0 8px 24px rgba(0,0,0,.35);
    }
    .card { background: var(--card); backdrop-filter: blur(10px); border:1px solid var(--border); border-radius: 16px; padding:12px 16px; box-shadow: 0 6px 24px rgba(0,0,0,.4); }
    .btn { pointer-events:auto; appearance: none; border: 1px solid var(--border); background: rgba(255,255,255,.06); color:#e6ecff; padding:12px 16px; border-radius:14px; font-weight:700; cursor:pointer; transition: transform .08s ease, background .2s ease, box-shadow .2s ease; }
    .btn:hover { background: rgba(255,255,255,.12); box-shadow: 0 6px 16px rgba(0,0,0,.25); }
    .btn:active{ transform: translateY(1px) scale(.99); }
    .btn.primary{ background: linear-gradient(180deg, #2a7cff, #2569f8); border-color: transparent; color:white; box-shadow: 0 10px 24px rgba(37,105,248,.35); }
    .btn.primary:hover{ filter: brightness(1.05); }
    #centerOverlay { position: absolute; inset: 0; display:flex; align-items:center; justify-content:center; pointer-events:auto; }
    .panel { width:min(92vw, 520px); background: rgba(10,16,40,.85); border:1px solid var(--border); border-radius: 22px; padding: 24px; box-shadow: 0 16px 48px rgba(0,0,0,.55); }
    .title { font-size: clamp(26px, 5vw, 40px); font-weight: 900; margin: 0 0 8px; letter-spacing: .4px; background: linear-gradient(90deg, var(--accent), var(--accent2)); -webkit-background-clip:text; background-clip:text; color: transparent; }
    .muted { color: var(--muted); font-size:14px; }
    .row { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; }
    .grow { flex:1 1 auto; }
    input[type="text"] { width: 100%; background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.18); color:#e6ecff; padding:12px 14px; border-radius: 12px; outline: none; font-size: 16px; }
    #leaderboard { max-height: 240px; overflow:auto; }
    ol#lbList{ list-style:none; margin:0; padding:0; counter-reset: rank; display:flex; flex-direction:column; gap:8px; }
    ol#lbList li{ counter-increment: rank; display:flex; align-items:center; justify-content:space-between; gap:10px; background: rgba(255,255,255,.04); border:1px solid var(--border); border-radius:12px; padding:10px 12px; }
    ol#lbList li::before{ content: counter(rank) "."; opacity:.6; width:2ch; margin-right:6px; }
    #footer { position: absolute; right: 12px; bottom: 12px; opacity:.7; font-size: 12px; padding-bottom: env(safe-area-inset-bottom); }
    canvas { display:block; touch-action: none; }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="ui">
    <div class="hud">
      <button class="btn" id="pauseBtn" aria-label="일시정지" type="button">⏸︎</button>
    </div>
    <div class="score-pill pill">점수 <b id="score">0</b></div>
    <div id="centerOverlay">
      <div class="panel">
        <h1 class="title" id="overlayTitle">Meteor Dodge</h1>
        <p class="muted" id="overlayDesc">손가락을 대고 비행선을 움직여 운석을 피하세요. 시간이 지날수록 더 어려워집니다.</p>

        <div id="gameOverBlock" hidden>
          <p style="margin:.5rem 0 0">이번 점수: <b id="finalScore">0</b></p>
          <div class="row" style="margin-top:10px">
            <input id="nickname" type="text" maxlength="16" placeholder="닉네임" class="grow" />
            <button id="saveBtn" class="btn" type="button">랭킹 등록</button>
          </div>
          <p class="muted" id="saveStatus" style="min-height:1.2em"></p>
        </div>

        <div style="display:flex; gap:12px; margin-top:12px; flex-wrap:wrap">
          <button id="startBtn" class="btn primary" style="font-size:18px" type="button">▶ 시작</button>
          <button id="restartBtn" class="btn" hidden type="button">다시 시작</button>
        </div>

        <h3 style="margin:16px 0 6px">🏆 실시간 랭킹 Top 10</h3>
        <div id="leaderboard" class="card" style="padding:12px">
          <ol id="lbList"></ol>
        </div>
      </div>
    </div>
    <div id="footer">Made for mobile · 드래그/터치 조작</div>
  </div>

  <script type="module">
    import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

    // 1) 여기에 본인 프로젝트 값 채우기 (환경변수 권장)
    const SUPABASE_URL = "https://hgjdlqqhvgwzszwwnlpr.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhnamRscXFodmd3enN6d3dubHByIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUxMzU4MDEsImV4cCI6MjA3MDcxMTgwMX0.yveInn8yTSH3325zIJ6wKjH72JyrKZBvaTngEuKDNJY";

    // 2) Supabase 클라이언트 (플레이스홀더면 비활성화)
    const hasCreds =
      SUPABASE_URL.startsWith('http') &&
      !SUPABASE_URL.includes('REPLACE') &&
      SUPABASE_ANON_KEY &&
      !SUPABASE_ANON_KEY.includes('REPLACE');

    const sb = hasCreds ? createClient(SUPABASE_URL, SUPABASE_ANON_KEY) : null;

    // DOM
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const pauseBtn = document.getElementById('pauseBtn');
    const overlay = document.getElementById('centerOverlay');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayDesc = document.getElementById('overlayDesc');
    const gameOverBlock = document.getElementById('gameOverBlock');
    const finalScoreEl = document.getElementById('finalScore');
    const nicknameInput = document.getElementById('nickname');
    const saveBtn = document.getElementById('saveBtn');
    const saveStatus = document.getElementById('saveStatus');
    const lbList = document.getElementById('lbList');

    // 캔버스 크기 & DPR (iOS 주소창/노치 대응: visualViewport 활용)
    const state = {
      w: 0, h: 0, dpr: 1,
      running: false, paused: false,
      time: 0, score: 0, lastSpawn: 0, spawnInterval: 1200,
      meteors: [],
      meteorParticles: [],
      particleCap: 3000,
      shipTrail: [],
      pointer: { active:false, x:0, y:0 },
      ship: { x:0, y:0, r: 18, speed: 0.18, angle: -Math.PI/2 },
      overlayFX: { active:false, t:0, dir: -1 }, // dir:-1 = fade out (start), 1 = fade in (game over)
      warmupMs: 2500, // 시작 2.5초는 스폰 금지 (튜토리얼/적응 시간)
      starLayers: [],
      nebulae: []
    };

    // ====== 유틸을 먼저 선언하여 fit() 최초 실행 전에도 사용 가능하게 ======
    function rand(a,b){ return a + Math.random()*(b-a); }
    const clamp01 = (x)=> Math.max(0, Math.min(1, x));
    const smoothstep = (e0,e1,x)=>{ const t = clamp01((x-e0)/(e1-e0)); return t*t*(3-2*t); };
    const easeInOut = (t)=> t<0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2;
    function tailParams(m){
      const speed = Math.hypot(m.vx, m.vy);
      const tail = Math.max(m.r*0.8, Math.min(140, speed*0.6));
      const width = Math.max(m.r*0.6, Math.min(60, speed*0.3));
      return { tail, width, speed };
    }

    function fit() {
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      const vw = window.visualViewport ? Math.floor(window.visualViewport.width) : window.innerWidth;
      const vh = window.visualViewport ? Math.floor(window.visualViewport.height) : window.innerHeight;
      state.w = vw; state.h = vh; state.dpr = dpr;
      canvas.width = Math.floor(state.w * dpr);
      canvas.height = Math.floor(state.h * dpr);
      canvas.style.width = state.w + 'px';
      canvas.style.height = state.h + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      regenStars();
      regenNebulae();
    }
    window.addEventListener('resize', fit);
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', fit);
      window.visualViewport.addEventListener('scroll', fit);
    }
    // 유틸이 선언된 이후에 최초 fit() 호출
    fit();

    // 입력 (터치 스크롤/풀투리프레시 방지)
    function setPointer(e){
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX ?? (e.touches?.[0]?.clientX || 0)) - rect.left;
      const y = (e.clientY ?? (e.touches?.[0]?.clientY || 0)) - rect.top;
      state.pointer.x = Math.max(0, Math.min(state.w, x));
      state.pointer.y = Math.max(0, Math.min(state.h, y));
    }
    canvas.addEventListener('pointerdown', e=>{ state.pointer.active=true; setPointer(e); });
    canvas.addEventListener('pointermove', e=>{ if(state.pointer.active) setPointer(e); });
    window.addEventListener('pointerup', ()=>{ state.pointer.active=false; });

    canvas.addEventListener('touchstart', e=> e.preventDefault(), {passive:false});
    canvas.addEventListener('touchmove', e=> e.preventDefault(), {passive:false});
    document.addEventListener('touchmove', (e)=>{
      if(e.target === document.body || e.target === canvas) e.preventDefault();
    }, {passive:false});

    // ───────────────────────
    // Starfield & Nebula generators
    // ───────────────────────
    function regenStars(){
      const area = state.w * state.h;
      const total = Math.max(120, Math.min(240, Math.floor(area / 6000)));
      const c0 = Math.floor(total*0.3), c1 = Math.floor(total*0.45);
      const counts = [c0, c1, total - c0 - c1];
      const speeds = [6, 12, 24]; // px/s
      const sizes = [[0.6,1.1],[0.8,1.6],[1.0,2.2]];
      const tw = [0.003,0.004,0.006];
      const palette = ['rgba(220,235,255,1)','rgba(255,236,200,1)','rgba(200,215,255,1)'];
      state.starLayers = [];
      for(let li=0; li<3; li++){
        const stars=[];
        for(let i=0;i<counts[li];i++){
          const r = rand(sizes[li][0], sizes[li][1]);
          const color = palette[(Math.random()*palette.length)|0];
          stars.push({x: Math.random()*state.w, y: Math.random()*state.h, r, baseA: rand(0.55, 1.0), twinkle: tw[li], phase: Math.random()*Math.PI*2, core: color});
        }
        const dir = Math.random()<0.5?1:-1;
        state.starLayers.push({stars, vx: speeds[li]*dir, vy: speeds[li]*0.15});
      }
    }
    function regenNebulae(){
      const n = 3;
      const colors = ['rgba(90,140,255,0.12)','rgba(180,100,255,0.10)','rgba(80,220,200,0.10)'];
      const minR = Math.min(state.w, state.h)*0.35, maxR = Math.min(state.w, state.h)*0.6;
      state.nebulae = [];
      for(let i=0;i<n;i++){
        const r = rand(minR, maxR);
        state.nebulae.push({
          x: rand(0, state.w), y: rand(0, state.h), r, a: rand(0.25,0.45),
          color1: colors[i%colors.length], vx: rand(-5,5), vy: rand(-3,3)
        });
      }
    }

    function spawnMeteor() {
      const edge = (Math.random()*4)|0;
      const size = rand(10, 28);
      let x,y;
      if(edge===0){ x = rand(0, state.w); y = -size-2; }
      else if(edge===1){ x = state.w+size+2; y = rand(0, state.h); }
      else if(edge===2){ x = rand(0, state.w); y = state.h+size+2; }
      else { x = -size-2; y = rand(0, state.h); }
      const targetX = state.ship.x + rand(-80,80);
      const targetY = state.ship.y + rand(-80,80);
      const dx = targetX - x; const dy = targetY - y; const len = Math.hypot(dx,dy) || 1;
      const baseSpeed = 70 + (state.time * 0.015);
      const vx = dx/len * baseSpeed; const vy = dy/len * baseSpeed;
      state.meteors.push({ x,y, r:size, vx, vy });
    }

    function resetGame() {
      state.time = 0; state.score = 0; state.lastSpawn = 0; state.spawnInterval = 1200;
      state.meteors.length = 0;
      state.ship.x = state.w*0.5; state.ship.y = state.h*0.7; state.ship.angle = -Math.PI/2;
      state.pointer.x = state.ship.x; state.pointer.y = state.ship.y;
    }

    function startGame() {
      // overlay fade-out + scale-down (표시 효과는 CSS/DOM으로 처리)
      state.overlayFX.active = true; state.overlayFX.t = 0; state.overlayFX.dir = -1;
      overlay.hidden = true; overlay.style.display = 'none';
      gameOverBlock.hidden = true;
      state.running = true; state.paused = false;
      pauseBtn.textContent = '⏸︎';
      resetGame();
      if (screen.orientation && screen.orientation.lock) {
        screen.orientation.lock('portrait').catch(()=>{});
      }
    }

    function gameOver() {
      state.running = false;
      // overlay fade-in + scale-up
      state.overlayFX.active = true; state.overlayFX.t = 0; state.overlayFX.dir = 1;
      overlay.hidden = false; overlay.style.display = 'flex';
      overlayTitle.textContent = '게임 종료';
      overlayDesc.textContent = '운석과 충돌했습니다. 닉네임을 입력하고 랭킹에 등록해보세요!';
      gameOverBlock.hidden = false;
      finalScoreEl.textContent = state.score.toString();
      restartBtn.hidden = false; startBtn.hidden = true;
      nicknameInput.value = localStorage.getItem('md.nickname') || '';
      saveBtn.disabled = false; saveStatus.textContent = '';
      nicknameInput.focus();
      fetchLeaderboard();
    }

    function togglePause() {
      if(!state.running) return;
      state.paused = !state.paused;
      pauseBtn.textContent = state.paused ? '▶' : '⏸︎';
      if(!state.paused) lastTs = performance.now();
    }
    pauseBtn.addEventListener('click', togglePause);
    startBtn.addEventListener('click', startGame);
    startBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); startGame(); }, {passive:false});
    restartBtn.addEventListener('click', ()=>{ startBtn.hidden = true; startGame(); });
    restartBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); startGame(); }, {passive:false});

    // 리더보드
    async function fetchLeaderboard(){
      lbList.innerHTML = '<li class="muted">불러오는 중...</li>';
      if(!sb){ lbList.innerHTML = '<li class="muted">저장소가 설정되지 않아 랭킹을 불러올 수 없습니다.</li>'; return; }
      const { data, error } = await sb.from('scores')
        .select('nickname, score, created_at')
        .order('score', { ascending:false })
        .limit(10);
      if(error){ lbList.innerHTML = `<li class=\"muted\">오류: ${error.message}</li>`; return; }
      lbList.innerHTML = '';
      (data||[]).forEach((row)=>{
        const li = document.createElement('li');
        li.textContent = `${row.nickname} — ${row.score}`;
        lbList.appendChild(li);
      });
      if((data||[]).length===0){
        lbList.innerHTML = '<li class="muted">아직 점수가 없습니다. 첫 기록의 주인공이 되어보세요!</li>';
      }
    }

    async function saveScore(){
      const nick = (nicknameInput.value||'').trim().slice(0,16);
      if(!nick){ saveStatus.textContent = '닉네임을 입력하세요.'; return; }
      if(!sb){ saveStatus.textContent = '저장소가 설정되지 않아 저장할 수 없습니다.'; return; }
      const payload = { nickname: nick, score: state.score };
      saveBtn.disabled = true; saveStatus.textContent = '저장 중...';
      const { error } = await sb.from('scores').insert(payload);
      if(error){ saveStatus.textContent = '실패: '+error.message; saveBtn.disabled=false; return; }
      localStorage.setItem('md.nickname', nick);
      saveStatus.textContent = '저장 완료!';
      fetchLeaderboard();
    }
    saveBtn.addEventListener('click', saveScore);

    // 초기 오버레이 & 랭킹 로드
    overlay.hidden = false; fetchLeaderboard();

    // 렌더링
    function drawShip(){
      const { x, y, r } = state.ship;
      // 잔광(트레일)
      state.shipTrail.push({x, y, a: 0.35});
      if (state.shipTrail.length > 24) state.shipTrail.shift();
      for(let i=0;i<state.shipTrail.length;i++){
        const t = state.shipTrail[i];
        const alpha = Math.max(0, t.a - i*0.02);
        if(alpha<=0) continue;
        const grd = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, r*1.2);
        grd.addColorStop(0, `rgba(123,240,255,${alpha*0.35})`);
        grd.addColorStop(1, 'rgba(123,240,255,0)');
        ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(t.x, t.y, r*1.5, 0, Math.PI*2); ctx.fill();
      }
      // 본체(네온 우주선)
      ctx.save(); ctx.translate(x,y); ctx.rotate(state.ship.angle + Math.PI/2);
      const g = ctx.createLinearGradient(0,-r*1.6,0,r*1.8);
      g.addColorStop(0,'#9ad7ff'); g.addColorStop(1,'#5fb3ff');
      ctx.beginPath();
      ctx.moveTo(0, -r*1.3);
      ctx.quadraticCurveTo(r*0.9, -r*0.2, r*0.8, r*1.0);
      ctx.lineTo(-r*0.8, r*1.0);
      ctx.quadraticCurveTo(-r*0.9, -r*0.2, 0, -r*1.3);
      ctx.closePath();
      ctx.fillStyle = g; ctx.shadowColor = '#6bd1ff'; ctx.shadowBlur = 18; ctx.fill();
      ctx.shadowBlur = 0;
      // 캐노피
      ctx.beginPath(); ctx.ellipse(0, -r*0.2, r*0.45, r*0.3, 0, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,.6)'; ctx.fill();
      // 테두리
      ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(255,255,255,.35)'; ctx.stroke();
      // 엔진 화염
      ctx.beginPath();
      ctx.moveTo(0, r*1.0); ctx.lineTo(r*0.38, r*1.8); ctx.lineTo(-r*0.38, r*1.8); ctx.closePath();
      const flame = ctx.createLinearGradient(0, r*1.0, 0, r*1.8);
      flame.addColorStop(0,'#ffe08a'); flame.addColorStop(1,'#ff6b6b');
      ctx.fillStyle = flame; ctx.fill();
      ctx.restore();
    }

    function drawMeteor(m){
      // (변경) 빛 플레어 제거 → 불꽃 파티클만 남김
      const tp = tailParams(m);
      const fAng = Math.atan2(m.vy, m.vx); // 정방향(이동 방향)

      // 꼬리 파티클(불똥) — 이동 반대 방향(-정방향)에서 방출
      const backX = m.x - Math.cos(fAng) * (m.r*0.6);
      const backY = m.y - Math.sin(fAng) * (m.r*0.6);
      const count = Math.min(16, Math.max(10, Math.round(tp.speed / 26)));
      for(let k=0; k<count && state.meteorParticles.length < state.particleCap; k++){
        state.meteorParticles.push({
          x: backX + rand(-2.6,2.6),
          y: backY + rand(-2.6,2.6),
          vx: -m.vx*0.12 + rand(-16,16),
          vy: -m.vy*0.12 + rand(-16,16),
          r: Math.max(2.0, m.r*0.24*rand(0.7,1.3)),
          a: 0.35
        });
      }

      // 본체(광택 있는 운석)
      const g = ctx.createRadialGradient(m.x-m.r*0.3, m.y-m.r*0.3, m.r*0.1, m.x, m.y, m.r);
      g.addColorStop(0, '#f5a67a');
      g.addColorStop(1, '#8a4025');
      ctx.fillStyle = g; ctx.beginPath(); ctx.arc(m.x, m.y, m.r, 0, Math.PI*2); ctx.fill();
      // 림 하이라이트
      ctx.strokeStyle = 'rgba(255,230,210,.25)'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(m.x, m.y, m.r*0.92, Math.PI*0.1, Math.PI*0.6); ctx.stroke();
      // 작은 크레이터
      ctx.fillStyle = 'rgba(0,0,0,.15)';
      for(let i=0;i<3;i++){ ctx.beginPath(); ctx.arc(m.x+rand(-m.r*0.4,m.r*0.4), m.y+rand(-m.r*0.4,m.r*0.4), m.r*rand(0.08,0.16), 0, Math.PI*2); ctx.fill(); }
    }

    function update(dt){
      state.time += dt;
      const targetInterval = Math.max(260, 1200 - state.time * 0.15);
      state.spawnInterval += (targetInterval - state.spawnInterval)*0.05;
      // 스폰: 워밍업 이후 서서히 강해지도록 확률적 게이팅 + 부드러운 배치 증가
      if(state.time >= state.warmupMs && (state.time - state.lastSpawn > state.spawnInterval)){
        const afterWarm = state.time - state.warmupMs;
        const warmRamp = smoothstep(0, 4000, afterWarm); // 워밍업 종료 후 4초 동안 0→1로 천천히
        if(Math.random() < warmRamp){
          state.lastSpawn = state.time;
          // 멀티 스폰 확률을 5s→35s 사이에서 부드럽게 0→0.6로
          const chaos = 0.6 * easeInOut(clamp01((state.time - 5000) / 30000));
          let batch = 1;
          if(Math.random() < chaos) batch++;
          if(Math.random() < chaos * 0.35) batch++; // 늦게 갈수록 드물게 3개
          const cap = 6 + Math.floor(state.time / 10000); // (테스트 유지) 동시 수 상한은 정수 그대로
          for(let i=0;i<batch && state.meteors.length < cap;i++) spawnMeteor();
        }
      }
      state.score = Math.floor(state.time/100);
      state.ship.x += (state.pointer.x - state.ship.x) * state.ship.speed;
      state.ship.y += (state.pointer.y - state.ship.y) * state.ship.speed;
      // 회전: 포인터 방향을 향하도록 각도 보간
      {
        const dxp = state.pointer.x - state.ship.x;
        const dyp = state.pointer.y - state.ship.y;
        const targetAng = Math.atan2(dyp, dxp);
        const a = state.ship.angle;
        let diff = ((targetAng - a + Math.PI) % (Math.PI*2)) - Math.PI; // [-π, π]
        const lerp = Math.min(1, 0.12 + 0.0003 * state.time); // 점점 더 민첩하게 회전
        state.ship.angle = a + diff * lerp;
      }
      // 운석 이동
      for(const m of state.meteors){ m.x += m.vx * dt/1000; m.y += m.vy * dt/1000; }
      // 별자리/성운 드리프트 & 래핑
      for(const L of state.starLayers){
        for(const s of L.stars){
          s.x += L.vx * dt/1000; s.y += L.vy * dt/1000;
          if(s.x < -s.r) s.x += state.w + s.r; if(s.x > state.w + s.r) s.x -= state.w + s.r;
          if(s.y < -s.r) s.y += state.h + s.r; if(s.y > state.h + s.r) s.y -= state.h + s.r;
        }
      }
      for(const nb of state.nebulae){
        nb.x += nb.vx*dt/1000; nb.y += nb.vy*dt/1000;
        const pad = nb.r*0.5;
        if(nb.x < -pad) nb.x += state.w + pad*2; if(nb.x > state.w + pad) nb.x -= state.w + pad*2;
        if(nb.y < -pad) nb.y += state.h + pad*2; if(nb.y > state.h + pad) nb.y -= state.h + pad*2;
      }
      // 파티클 업데이트
      for(const p of state.meteorParticles){ p.x += p.vx*dt/1000; p.y += p.vy*dt/1000; p.vx*=0.986; p.vy*=0.986; p.a -= 0.0024*dt; p.r*=0.999; }
      state.meteorParticles = state.meteorParticles.filter(p=> p.a>0.02 && p.r>0.5);
      // 화면 밖 제거
      const margin = 80;
      state.meteors = state.meteors.filter(m => m.x>-margin && m.x<state.w+margin && m.y>-margin && m.y<state.h+margin);
      // 충돌
      for(const m of state.meteors){
        const dx = m.x - state.ship.x, dy = m.y - state.ship.y;
        if(dx*dx + dy*dy < (m.r + state.ship.r*0.9)**2){ gameOver(); break; }
      }
      // 오버레이 효과 진행(0→1)
      if(state.overlayFX.active){
        state.overlayFX.t = Math.min(1, state.overlayFX.t + dt/250);
        if(state.overlayFX.t >= 1) state.overlayFX.active = false;
      }
    }

    function render(){
      ctx.clearRect(0,0,state.w,state.h);
      // 우주 배경: 성운 + 별자리
      // 성운 (screen 블렌딩으로 은은하게)
      ctx.save(); ctx.globalCompositeOperation = 'screen';
      for(const nb of state.nebulae){
        ctx.globalAlpha = nb.a;
        const g = ctx.createRadialGradient(nb.x, nb.y, nb.r*0.1, nb.x, nb.y, nb.r);
        g.addColorStop(0, nb.color1); g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g; ctx.beginPath(); ctx.arc(nb.x, nb.y, nb.r, 0, Math.PI*2); ctx.fill();
      }
      // 별자리 (3 레이어, 파랄럭스 + 점멸)
      for(const L of state.starLayers){
        for(const s of L.stars){
          const tw = s.baseA * (0.6 + 0.4*Math.sin(state.time*s.twinkle + s.phase));
          ctx.globalAlpha = tw;
          const g = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.r);
          g.addColorStop(0, s.core); g.addColorStop(1, 'rgba(255,255,255,0)');
          ctx.fillStyle = g; ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fill();
        }
      }
      ctx.restore();
      // 운석 파티클 꼬리
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for(const p of state.meteorParticles){
        if (p.a < 0.06) continue;
        ctx.globalAlpha = Math.max(0, p.a) * 0.8;
        const gg = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r);
        gg.addColorStop(0,'rgba(255,200,150,0.85)'); gg.addColorStop(1,'rgba(255,200,150,0)');
        ctx.fillStyle = gg; ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
      }
      ctx.globalAlpha = 1;
      ctx.restore();
      // 운석
      for(const m of state.meteors) drawMeteor(m);
      // 비행선
      drawShip();
      // HUD
      scoreEl.textContent = state.score.toString();
    }

    let lastTs = performance.now();
    function loop(ts){
      if(!state.running){ requestAnimationFrame(loop); return; }
      const dt = Math.min(32, ts - lastTs); lastTs = ts;
      if(!state.paused){ update(dt); render(); }
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    overlayTitle.textContent = 'Meteor Dodge';
    overlayDesc.textContent = '터치를 누르고 드래그하면 비행선이 따라옵니다. 운석을 피해 오래 살아남으세요!';

    // ───────────────────────
    // Runtime tests (opt-in): add ?test=1 to URL — includes warmup/cap/rotation/tail checks
    // ───────────────────────
    function assert(name, cond){ if(!cond) throw new Error('Test failed: '+name); console.log('✓', name); }
    async function runTests(){
      console.log('[TEST] start');
      // Extra Test: rand is available before any star regen usage
      assert('rand available', typeof rand === 'function');

      // Test: startGame hides overlay and sets running
      startGame();
      assert('running true', state.running === true);
      assert('overlay hidden', overlay.hidden === true && overlay.style.display === 'none');

      // Test: meteor spawn creates valid object
      const before = state.meteors.length;
      spawnMeteor();
      assert('meteor spawned', state.meteors.length === before + 1);
      const m = state.meteors[state.meteors.length-1];
      assert('meteor velocity finite', Number.isFinite(m.vx) && Number.isFinite(m.vy));

      // Test: collision logic causes gameOver (state.running becomes false)
      m.x = state.ship.x; m.y = state.ship.y; m.r = 50; // 강제로 충돌
      update(0);
      assert('collision triggers gameOver', state.running === false);

      // Extra Test: gameOver re-enables save button
      assert('save enabled after gameOver', saveBtn.disabled === false);

      // Extra Test: trail renders after movement + render
      startGame();
      state.pointer.x = state.ship.x + 100; // 이동 유도
      update(16); render();
      assert('ship trail created', state.shipTrail.length > 0);

      // Extra Test: ship rotates toward pointer (right)
      startGame();
      state.pointer.x = state.ship.x + 200; state.pointer.y = state.ship.y;
      for(let t=0;t<15;t++){ update(16); }
      let angDiff = Math.abs(((state.ship.angle - 0 + Math.PI) % (Math.PI*2)) - Math.PI);
      assert('ship rotates right', angDiff < 0.5);

      // Extra Test: ship rotates toward pointer (up)
      startGame();
      state.pointer.x = state.ship.x; state.pointer.y = state.ship.y - 200;
      for(let t=0;t<15;t++){ update(16); }
      angDiff = Math.abs(((state.ship.angle - (-Math.PI/2) + Math.PI) % (Math.PI*2)) - Math.PI);
      assert('ship rotates up', angDiff < 0.5);

      // Extra Test: warmup prevents early spawns
      startGame();
      const beforeWarm = state.meteors.length;
      update(1000); // 1s < warmupMs(2.5s)
      assert('no spawn during warmup', state.meteors.length === beforeWarm);

      // Extra Test: after warmup, at most cap meteors
      startGame();
      for(let t=0;t<6000;t+=300){ update(300); }
      const cap = 6 + Math.floor(state.time / 10000);
      assert('cap respected', state.meteors.length <= cap);

      // Extra Test: tailParams bounds
      let tp = tailParams({vx:0, vy:0, r:20});
      assert('tail >= r*0.8 when slow', tp.tail >= 16);
      assert('width >= r*0.6 when slow', tp.width >= 12);
      tp = tailParams({vx:1000, vy:0, r:20});
      assert('tail <= 140 cap', tp.tail <= 140);

      // Extra Test: tail back point is opposite to velocity
      {
        const testM = {x:100, y:100, r:20, vx:60, vy:0};
        const ang = Math.atan2(testM.vy, testM.vx) + Math.PI;
        const backX = testM.x + Math.cos(ang) * (testM.r*0.6);
        const backY = testM.y + Math.sin(ang) * (testM.r*0.6);
        const v = [testM.vx, testM.vy];
        const b = [backX - testM.x, backY - testM.y];
        const dot = v[0]*b[0] + v[1]*b[1];
        assert('tail back point opposite velocity', dot < 0);
      }

      // Extra Test: tail flare direction opposite velocity
      {
        const testM2 = {x:0, y:0, r:20, vx:0, vy:80}; // 아래로 이동(스크린 좌표 +y)
        const fAng = Math.atan2(testM2.vy, testM2.vx);
        const tailDir = [-Math.cos(fAng), -Math.sin(fAng)]; // 뒤쪽(-정방향)
        const vel = [testM2.vx, testM2.vy];
        const dot2 = tailDir[0]*vel[0] + tailDir[1]*vel[1];
        assert('tail flare opposite velocity', dot2 < 0);
      }

      // Extra Test: drawMeteor should not throw
      try {
        drawMeteor({x:120, y:90, r:14, vx:80, vy:0});
        assert('drawMeteor did not throw', true);
      } catch(e) {
        throw new Error('drawMeteor threw: '+e.message);
      }

      // Extra Test: particle cap respected
      startGame();
      for(let i=0;i<30;i++){ spawnMeteor(); }
      for(let t=0;t<4000;t+=16){ update(16); }
      assert('particle cap respected', state.meteorParticles.length <= state.particleCap);

      // Extra Test: high-speed meteor spawns many particles (>=10)
      {
        const beforeP = state.meteorParticles.length;
        drawMeteor({x:200,y:200,r:20,vx:400,vy:0});
        const spawned = state.meteorParticles.length - beforeP;
        assert('many particles on high speed', spawned >= 10);
      }

      // Extra Test: particle size boosted
      {
        const p = state.meteorParticles[state.meteorParticles.length - 1];
        assert('particle radius >= 2', p.r >= 2);
      }

      // Extra Test: particle cap respected
      startGame();
      for(let i=0;i<30;i++){ spawnMeteor(); }
      for(let t=0;t<4000;t+=16){ update(16); }
      assert('particle cap respected', state.meteorParticles.length <= state.particleCap);

      // Extra Test: starfield/nebula populated
      assert('star layers exist', Array.isArray(state.starLayers) && state.starLayers.length===3);
      const totalStars = state.starLayers.reduce((acc,L)=> acc + L.stars.length, 0);
      assert('stars populated', totalStars >= 100);
      assert('nebulae populated', Array.isArray(state.nebulae) && state.nebulae.length >= 2);

      console.log('[TEST] all passed');
      alert('All runtime tests passed.');
    }
    if (location.search.includes('test=1')) {
      runTests().catch(e=>{ console.error(e); alert(e.message); });
    }

  </script>

  <!-- (선택) PWA 설치를 원하면 HTTPS 배포 후 아래 두 파일을 함께 올리세요. -->
  <!-- manifest.json
  {
    "name": "Meteor Dodge",
    "short_name": "Meteor",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0b1020",
    "theme_color": "#0b1020",
    "icons": [
      { "src": "icon-192.png", "sizes": "192x192", "type": "image/png" },
      { "src": "icon-512.png", "sizes": "512x512", "type": "image/png" }
    ]
  }
  -->
  <!-- sw.js
  const CACHE = 'md-v1';
  self.addEventListener('install', e=>{
    e.waitUntil(caches.open(CACHE).then(c=>c.addAll(['./','./index.html'])));
  });
  self.addEventListener('fetch', e=>{
    e.respondWith(caches.match(e.request).then(r=> r || fetch(e.request)));
  });
  -->
</body>
</html>
